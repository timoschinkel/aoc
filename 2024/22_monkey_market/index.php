<?php

declare(strict_types=1);

namespace Timoschinkel\Aoc2024\Day22;

require_once dirname(__DIR__) . DIRECTORY_SEPARATOR . 'Stopwatch.php';

$input = __DIR__ . DIRECTORY_SEPARATOR . ($argv[1] ?? 'example') . '.txt';

$rows = array_filter(explode(PHP_EOL, file_get_contents($input)));

// Read input
$numbers = array_map('intval', $rows);

$sw = new \Stopwatch();

/**
 * Idea one; let's just implement the rules. Within 10 iterations I exceeded the maximum value of a 64-bit integer in
 * PHP. I was able to rewrite to GMP. The runtime is approx. 5 seconds, which is too much, but it does get an answer.
 * 
 * Optimization
 * The solution took way too long, there must be a faster solution. I noticed the numbers 64, 32 and 2048. Those are
 * multiples of 2, and that is an indication of binary operations. After doing some trial and error - and some research - 
 * I realised that multiplying by 0x1000000 (64) is equivalent of bit shifting 6 positions left. The operation that 
 * stumped me was the %16777216, but I found help on [Reddit][reddit] and learned that %16777216 is equivalent of &0xffffff.
 * I was able to rewrite the entire solution to binary operations, bringing down the runtime to a little over 100ms.
 * 
 * [Reddit]: https://www.reddit.com/r/adventofcode/comments/1hjroap/comment/m390z6x/
 * 
 * @param int[] $numbers
 * @return int
 */
function part_one(array $numbers): int {
    $sum = 0;
    foreach ($numbers as $number) {
        for ($i = 0; $i < 2000; $i++) {
            $number = $number ^ $number << 6 /* *64 */;
            $next = $number & 0xffffff /* %16777216 */;
            $number = $number ^ $next >> 5 /* /32 */;
            $next = $number & 0xffffff;
            $number = $number ^ $number << 11 /* *2048 */;
            $next = $number & 0xffffff;
        }
        $sum += $next;
    }

    return $sum;
}

$sw->start();
echo 'What is the sum of the 2000th secret number generated by each buyer? ' . part_one($numbers) . ' (' . $sw->ellapsed() . ')' . PHP_EOL;

/**
 * We need to find the sequence that yield the most bananas. We iterate over the random numbers and find the maximum 
 * value for any given pattern. We do this by creating a dictionary with all the sequences of four numbers and their 
 * yield. If we encounter the same sequence in another buyer that we add the value to it. That way we find the sequence
 * that will result in the most bananas.
 * 
 * @param int[] $numbers
 * @return int
 */
function part_two(array $numbers): int {
    $bananas = [];
    $max = 0;

    foreach ($numbers as $number) {
        $diffs = [];
        $prev = null;
        $sequences = [];

        for ($i = 0; $i < 2000; $i++) {
            // Copy of part 1
            $number = $number ^ $number << 6 /* *64 */;
            $next = $number & 0xffffff /* %16777216 */;
            $number = $number ^ $next >> 5 /* /32 */;
            $next = $number & 0xffffff;
            $number = $number ^ $number << 11 /* *2048 */;
            $next = $number & 0xffffff;

            // Administration
            $price = $next % 10; // get last digit
            if ($prev !== null) {
                $diffs[] = $prev - $price;
            }

            if (count($diffs) > 3) {
                $sequence = join(',', array_slice($diffs, -4)); // get last 4 diffs
                if (!isset($sequences[$sequence])) {
                    // new sequence found
                    $bananas[$sequence] = ($bananas[$sequence] ?? 0) + $price;
                    $sequences[$sequence] = $price;

                    // If we find a new max we can update
                    $max = max($max, $bananas[$sequence]);
                }
            }

            $prev = $price;
        }
    }

    return $max;
}

$sw->start();
echo 'What is the most bananas you can get? ' . part_two($numbers) . ' (' . $sw->ellapsed() . ')' . PHP_EOL;
